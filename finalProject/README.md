#Program Overview
	This is a port of the 1979 video game *Santa Paranoia and Fiumancco* written in C++ with modern “object-oriented” programming techniques. *Santa Paravia* is essentially a primitive, text-based version of the popular *Civilization* series in which the player controls a single town in 1400s Italy and is tasked with managing wealth and resources to allow growth.
	In making this project, I attempted to neatly split it into two parts: the objects and member functions that make up the game elements and mechanics, and the main program loop that would initialize objects and call functions as necessary to simulate gameplay and game flow, as will all be detailed below.

#Framework
##Helper Functions
	In addition to high-level classes representing game elements, the program’s framework also consists of a set of functions I wrote to carry out repetitive, low-level mechanical tasks in the program. This included functions for input validation, random number generation, random chance, and pausing the output.
##Classes and Members
	The player is the main element in the game. As an object, it consists of the player’s stats, as well as the stats for the player’s town, which can be bundled in since each player is assigned to a single town in the game. All of the data is stored in the class’s private access. The member functions in the class’s public access include functions representing in-game actions and events that can affect a player’s stats, as well as getter functions for read-only access of private data that is otherwise not intended for direct mutation.
###Back-end
	Within Santa Paranoia, the following in-game stats are present that needed to be represented in the class: the player’s gold, the current in-game year, the amounts of grain and land in the town, the amount of buildings owned in each of the four categories (markets, mills, cathedrals, palaces), the town’s population by category (serfs, merchants, clergy, soldiers, nobles), and the tax rates in the town by category (sales, income, customs). 
	In the 2000 C version of the game that I based this program off of, all of this was represented as a series of int variables, with all in-game behavior defined in front-end functions. While this was repeated for year, gold, and populations, I figured that, in the spirit of object-oriented programming, I could make the front-end implementation of the program easier by representing the other categories as structs consisting of both the main statistic and parameters for the shared behavior patterns exhibited by the particular game element.
	A total of three structs were defined for this within the scope of the player class. First is the commodity struct, which acts as a base class to represent all items in the game that could be bought or sold. It consists of members for the amount owned by the player, the price of the item in the player’s town, and the item’s name, for output purposes when buying or selling. Functions were created in the player class that would take a commodity object as a member and simulate the act of the player making a transaction. This was placed in private access to prevent unintended behavior such as a player calling the functions on another player’s commodity members. Grain, land, and soldiers are represented as commodities.
	Another struct was made to represent a specific category of commodities: assets. Assets in the game serve the purpose of generating income or bringing tax-paying citizens to the player’s town between game turns. The asset struct inherits members and static type from the commodity struct and also consists of parameters for the range of yearly income generated by the asset and the maximum population increase by category that each owned asset could cause. Functions for generating income and increasing population were written in a similar manner as the buy and sell functions for the commodity class. Markets, mills, cathedrals, and palaces are represented as asset objects.
	Lastly among the in-game elements are the taxes, which are represented in-game through a struct consisting of the tax rate as well as other parameters for  the amount of taxable wealth in the town, which is based on town population by category as well as assets in the town. For each tax category, all of this could be multiplied to get the total amount of tax revenue received by the player each turn.
###Front-end
	The player is capable to doing the following actions during their turn: buying assets and commodities, adjusting tax rates, releasing grain for consumption, or invading their neighbors. The first two were rather simple to implement in the public access after all of the back-end work and could mostly be written as single-line calls to helper functions defined in the private access. 
	The invasion function is the most complex of these. The player object calls it with another player object, representing the player being invaded, as the parameter. Casualties for both sides are calculated through a semi-random formula and are deducted from the players’ soldiers. If the defending player loses above a certain percentage of their soldiers, they lose the battle and the invading player takes a portion of their land and grain depending on the margin of victory. 
	In addition to functions representing actions, there are also a set of in-game events that occur between turns that can affect a player’s stats. People move in to, are born in, or die in the player’s town based on the amount of grain released or assets owned, grain gets harvested or lost to various causes, and the player receives revenue from taxes and has to pay expenses. Again, these are relatively simple operations that mainly consist of adding or deducting certain amounts from member variables in the class as necessary.
	Game over conditions are also built into the class. As of the current version, the endgame system is still relatively primitive. A function calculates and returns the player’s “score” based on their town stats. If their score exceeds a certain amount, the player is considered to have won the game. Meanwhile, if a certain amount of in-game turns pass, the player “dies” and is considered to have lost. The endgame conditions are enforced through exception calls that get triggered if action functions are called for the player after either condition is reached, requiring the player to be taken out of the game as intended. Handling for the conditions is deferred to the game flow.

#Program Flow
	With the player class and its associated elements defined, 